<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | Sojiro's Blog]]></title>
  <link href="http://sojiro14.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://sojiro14.github.io/"/>
  <updated>2017-06-16T02:35:46+09:00</updated>
  <id>http://sojiro14.github.io/</id>
  <author>
    <name><![CDATA[Sojiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Could Not Open the Requested Socket エラーが出たら]]></title>
    <link href="http://sojiro14.github.io/blog/2017/06/16/could-not-open-the-requested-socket-on-android-studio/"/>
    <updated>2017-06-16T02:28:06+09:00</updated>
    <id>http://sojiro14.github.io/blog/2017/06/16/could-not-open-the-requested-socket-on-android-studio</id>
    <content type="html"><![CDATA[<p>Android Studio で GAE に乗せるアプリを開発しているとき、ローカルで立ち上げようとすると以下のようなエラーが出た</p>

<pre><code>Could not open the requested socket: Address already in use
Try overriding --address and/or --port.
</code></pre>

<p>どうやら以前立ち上げた際のプロセスが生き残っていて邪魔しているらしい</p>

<h3>以下のように対応した</h3>

<p>Android Studio のメニューから <code>Run</code> → <code>Edit Configurations...</code> とたどり、対象 module が使っている port を確認</p>

<p>ポートを指定してプロセスを確認、そして <code>kill</code></p>

<pre><code class="bash">$ lsof -i:8080
COMMAND   PID    USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
java    74792  sojiro   48u  IPv6 0xXXXXXXXXXXXXXXXX      0t0  TCP *:http-alt (LISTEN)
</code></pre>

<pre><code class="bash">$ kill -9 74792
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[パーフェクトJava読書メモ Chapter 10 Javaプログラムの実行と制御構文]]></title>
    <link href="http://sojiro14.github.io/blog/2016/08/31/study-of-perfect-java-chapter-10/"/>
    <updated>2016-08-31T03:40:04+09:00</updated>
    <id>http://sojiro14.github.io/blog/2016/08/31/study-of-perfect-java-chapter-10</id>
    <content type="html"><![CDATA[<p>Javaを使うために<a href="http://www.amazon.co.jp/gp/product/4774166855/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=4774166855&amp;linkCode=as2&amp;tag=sojiro14-22">改訂2版 パーフェクトJava</a>を読んだメモ</p>

<h2>条件分岐</h2>

<h3>if-else文</h3>

<p>インデントの取り方に関係なく <code>else</code> は最も近い（直近の） <code>if</code> にかかる</p>

<h3>switch-case文</h3>

<pre><code class="java">switch(式) {
case 定数1:
    0個以上の文
case 定数N:
    0個以上の文
default:
    0個以上の文
}
</code></pre>

<p>式の評価値は以下</p>

<ul>
<li>int 型</li>
<li>int 型に暗黙に型変換される型

<ul>
<li>char</li>
<li>byte</li>
<li>short</li>
</ul>
</li>
<li>数値ラッパークラス

<ul>
<li>Integer</li>
<li>Character</li>
<li>Byte</li>
<li>Short</li>
</ul>
</li>
<li>enum 型</li>
<li>String 型</li>
</ul>


<p>式が <code>null</code> になると <code>NullPointerException</code> が発生する</p>

<p><code>break;</code> 文がない限り処理を続ける</p>

<pre><code class="java">int i = 0;
switch (i) {
    case 0:
        System.out.println(0);
    case 1:
        System.out.println(1);
    default:
        System.out.println("default");
}
</code></pre>

<pre><code class="java">0
1
default
</code></pre>

<h2>繰り返し</h2>

<h3>for文</h3>

<pre><code class="java">for (初期化式; 条件式; 更新式) {
    文
}
</code></pre>

<p>条件式は評価値が <code>boolean</code> もしくは <code>Boolean</code></p>

<p>初期化式と更新式は複数の式を <code>,</code> で区切って書ける</p>

<pre><code class="java">for (int i = 0, j = 0; (i &lt; 10 &amp;&amp; j &lt; 10); i++, j++) { 
}
</code></pre>

<p>異なる型の宣言と初期化を並べるとエラー</p>

<pre><code class="java">for (int i = 0, byte j = 0; (i &lt; 10 &amp;&amp; j &lt; 10); i++, j++) { 
}
</code></pre>

<p>for文の外に出して回避</p>

<pre><code class="java">int i;
byte j;
for (i = 0, j = 0; (i &lt; 10 &amp;&amp; j &lt; 10); i++, j++) { 
}
</code></pre>

<h2>ジャンプ</h2>

<h3>break文</h3>

<ul>
<li>ループを抜ける</li>
<li>ループがネストしている場合、抜けるのは内側のループのみ</li>
</ul>


<h3>continue文</h3>

<ul>
<li>ループ内の文をスキップしてループの条件式の評価に戻る</li>
</ul>


<h3>ラベル</h3>

<ul>
<li>繰り返しにラベルをつける</li>
<li>break文、continue文にラベルを渡すことでどの繰り返しを対象にするか定める</li>
</ul>


<pre><code class="java">target_loop:
while (true) {
    while (true) {
        break target_loop;
    }
}
</code></pre>

<ul>
<li>外側の while ループに <code>target_loop</code> というラベルがつく</li>
<li><code>break target_loop</code> で外側の while ループを抜ける</li>
<li>（ <code>continue</code> の場合は対象のループ内の文をスキップして条件式の評価に戻る）</li>
</ul>


<h2>参照</h2>

<p><a href="http://www.amazon.co.jp/gp/product/4774166855/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=4774166855&amp;linkCode=as2&amp;tag=sojiro14-22">改訂2版 パーフェクトJava</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[パーフェクトJava読書メモ Chapter 9 文、式、演算子]]></title>
    <link href="http://sojiro14.github.io/blog/2016/08/24/study-of-perfect-java-chapter-9/"/>
    <updated>2016-08-24T03:19:11+09:00</updated>
    <id>http://sojiro14.github.io/blog/2016/08/24/study-of-perfect-java-chapter-9</id>
    <content type="html"><![CDATA[<p>Javaを使うために<a href="http://www.amazon.co.jp/gp/product/4774166855/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=4774166855&amp;linkCode=as2&amp;tag=sojiro14-22">改訂2版 パーフェクトJava</a>を読んだメモ</p>

<h2>Java の文法と文</h2>

<p>Java で扱う文は以下の4種類</p>

<ul>
<li>制御文</li>
<li>ブロック文</li>
<li>宣言文</li>
<li>式文</li>
</ul>


<p>宣言文と式文は終端にセミコロン必要</p>

<h2>Java の演算子と式</h2>

<ul>
<li><code>&amp;&amp;</code> 、 <code>||</code> 、 <code>?</code> <code>:</code> （三項演算子）を除くすべての演算子は演算前にすべてのオペランドを評価する</li>
<li>オペランドは左のものから評価する</li>
<li>メソッド及びコンストラクタ呼び出し式では引数を左から評価する</li>
</ul>


<h2>数値の演算</h2>

<h3>インクリメント/デクリメント演算の前置後置</h3>

<p>前置演算は評価値が演算後の値、後置演算は評価値が演算前の値</p>

<pre><code class="java">int n = 10;
int m = ++n;
// m: 11, n: 11
int n = 10;
int m = n++;
// m: 10, n: 11
</code></pre>

<pre><code class="java">int n = 0;
while (++n &lt; 10) {
    // ループが回る回数は 9 回
}
</code></pre>

<h2>論理演算</h2>

<h3>遅延評価</h3>

<p><code>&amp;&amp;</code> 、<code>||</code> は遅延評価を行う</p>

<ul>
<li><code>&amp;&amp;</code> は左辺の評価値が偽であれば右辺の評価値に関係なく結果が偽になるため右辺を評価しない</li>
<li><code>||</code> は左辺の評価値が真であれば右辺の評価値に関係なく結果が真になるため右辺の評価をしない</li>
</ul>


<p>これらの演算子の右辺に副作用のある式を書くと、左辺の評価値により実行さるか否かが変わってくるので注意</p>

<h2>その他の演算</h2>

<h3>instanceof 演算子</h3>

<p>ダウンキャストを安全に行えるかを事前にチェックする</p>

<h2>参照</h2>

<p><a href="http://www.amazon.co.jp/gp/product/4774166855/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=4774166855&amp;linkCode=as2&amp;tag=sojiro14-22">改訂2版 パーフェクトJava</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[パーフェクトJava読書メモ Chapter 7 インターフェース]]></title>
    <link href="http://sojiro14.github.io/blog/2016/07/24/study-of-perfect-java-chapter-7/"/>
    <updated>2016-07-24T02:29:32+09:00</updated>
    <id>http://sojiro14.github.io/blog/2016/07/24/study-of-perfect-java-chapter-7</id>
    <content type="html"><![CDATA[<p>Javaを使うために<a href="http://www.amazon.co.jp/gp/product/4774166855/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=4774166855&amp;linkCode=as2&amp;tag=sojiro14-22">改訂2版 パーフェクトJava</a>を読んだメモ</p>

<h2>クラスとインターフェースの違い</h2>

<ul>
<li>インターフェースは雛形としての役割を持たない</li>
<li>インターフェースは実体化できず、型定義に特化している</li>
<li>インターフェースの継承の目的は多様性のみ（クラスの拡張継承には実装コードの共有という側面もある）</li>
</ul>


<h2>インターフェース宣言</h2>

<pre><code class="java">[修飾子] interface インターフェース名 {
    メンバ宣言
}
</code></pre>

<h3>インターフェースの修飾子</h3>

<table>
<thead>
<tr>
<th> modifier </th>
<th> description </th>
</tr>
</thead>
<tbody>
<tr>
<td> <code>public</code> </td>
<td> グローバルにアクセス可（書かないとパッケージ内に限定） </td>
</tr>
<tr>
<td> <code>abstract</code> </td>
<td> インターフェースは暗黙的に abstract なので書かなくても同じ </td>
</tr>
<tr>
<td> <code>strictfp</code> </td>
<td> インターフェース内に記述した浮動小数点演算を厳密に評価 </td>
</tr>
<tr>
<td> アノテーション </td>
<td> 省略 </td>
</tr>
</tbody>
</table>


<h3>インターフェースのメンバ</h3>

<ul>
<li>抽象メソッド（実装なし）</li>
<li>default メソッド</li>
<li>static メソッド</li>
<li>定数フィールド</li>
<li>static なネストしたクラス</li>
<li>static なネストしたインターフェース</li>
</ul>


<h3>メソッド宣言</h3>

<table>
<thead>
<tr>
<th> modifier </th>
<th> description </th>
</tr>
</thead>
<tbody>
<tr>
<td> <code>public</code> </td>
<td> 暗黙的に public なので書かなくても同じ</td>
</tr>
<tr>
<td> <code>default</code> </td>
<td> デフォルトメソッド </td>
</tr>
<tr>
<td> <code>static</code> </td>
<td> static メソッド </td>
</tr>
<tr>
<td> <code>abstract</code> </td>
<td> 暗黙的に abstract なので書かなくても同じ </td>
</tr>
</tbody>
</table>


<ul>
<li><code>default</code> メソッドはインスタンスメソッド</li>
<li>インターフェースを継承した具象クラスのインスタンスメソッドになる</li>
<li>フィールド変数は暗黙的に <code>public</code> <code>static</code> <code>final</code></li>
</ul>


<h2>インターフェースと実装クラス</h2>

<h3>インターフェース継承</h3>

<pre><code class="java">[修飾子] class クラス名 implements インターフェース名 {
    クラス本体
}
</code></pre>

<p>複数のインターフェースを同時に継承することができる</p>

<pre><code class="java">[修飾子] class クラス名 implements インターフェース名, インターフェース名 {
    クラス本体
}
</code></pre>

<ul>
<li>クラスの拡張継承とインターフェースの継承を同時にできる</li>
<li>このとき <code>implements</code> は <code>extends</code> より後に書く</li>
</ul>


<pre><code class="java">[修飾子] class クラス名 extends 親クラス名 implements インターフェース名 {
    クラス本体
}
</code></pre>

<ul>
<li>インターフェースを継承したクラスはインターフェースの抽象メソッドをすべてオーバーライドする必要がある</li>
<li>インターフェースから継承したメソッドのアクセス制御は <code>public</code> 修飾子がないとコンパイルエラー</li>
<li>メソッドのオーバーライドはクラスの拡張継承と同様に行う</li>
</ul>


<h3>ネストしたインターフェース</h3>

<ul>
<li>クラス内のネストしたインターフェース

<ul>
<li><code>public</code> <code>protected</code> 無指定 <code>private</code> のいずれかを指定する</li>
</ul>
</li>
<li>インターフェース内のネストしたインターフェース

<ul>
<li>常に <code>public</code></li>
</ul>
</li>
<li>インターフェース内のネストしたクラス

<ul>
<li>常に <code>public</code> かつ <code>static</code></li>
</ul>
</li>
<li>ネストして宣言されたインターフェースは常に <code>static</code></li>
</ul>


<h3>インターフェース自体の拡張継承</h3>

<ul>
<li>インターフェースも拡張継承できる</li>
<li>インターフェースは複数の親インターフェースを指定可能</li>
</ul>


<pre><code class="java">interface Parent {
    void print();
}

interface Child extends Parent {
    // void print() を継承
}

interface Father {
    void print();
}

interface Mother {
    void exec();
}

interface Child2 extends Father, Mother {
    // void print(), void exec() を継承
}
</code></pre>

<h2>参照</h2>

<p><a href="http://www.amazon.co.jp/gp/product/4774166855/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=4774166855&amp;linkCode=as2&amp;tag=sojiro14-22">改訂2版 パーフェクトJava</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[パーフェクトJava読書メモ Chapter 6 コレクションと配列]]></title>
    <link href="http://sojiro14.github.io/blog/2016/07/21/study-of-perfect-java-chapter-6/"/>
    <updated>2016-07-21T03:27:46+09:00</updated>
    <id>http://sojiro14.github.io/blog/2016/07/21/study-of-perfect-java-chapter-6</id>
    <content type="html"><![CDATA[<p>Javaを使うために<a href="http://www.amazon.co.jp/gp/product/4774166855/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=4774166855&amp;linkCode=as2&amp;tag=sojiro14-22">改訂2版 パーフェクトJava</a>を読んだメモ</p>

<h2>コレクションフレームワーク</h2>

<table>
<thead>
<tr>
<th> &mdash;&ndash; </th>
<th> Hash Table </th>
<th> Array      </th>
<th> Tree    </th>
<th> Linked List </th>
<th> Hash Table + Linked List </th>
</tr>
</thead>
<tbody>
<tr>
<td> set   </td>
<td> HashSet    </td>
<td> &mdash;        </td>
<td> TreeSet </td>
<td> &mdash;         </td>
<td> LinkedHashSet            </td>
</tr>
<tr>
<td> list  </td>
<td> &mdash;        </td>
<td> ArrayList  </td>
<td> &mdash;     </td>
<td> LinkedList  </td>
<td> &mdash;                      </td>
</tr>
<tr>
<td> deque </td>
<td> &mdash;        </td>
<td> ArrayDeque </td>
<td> &mdash;     </td>
<td> LinkedList  </td>
<td> &mdash;                      </td>
</tr>
<tr>
<td> map   </td>
<td> HashMap    </td>
<td> &mdash;        </td>
<td> TreeMap </td>
<td> &mdash;         </td>
<td> LinkedHashMap            </td>
</tr>
</tbody>
</table>


<h3>コレクション型オブジェクトの生成</h3>

<pre><code class="java">コレクションのインターフェース型&lt;要素の型&gt; 変数 = new コレクションのインターフェースを実装した具象クラス&lt;&gt;([コンストラクタの引数]);
</code></pre>

<pre><code class="java">List&lt;String&gt; list = new ArrayList&lt;&gt;();
</code></pre>

<ul>
<li>上記例で <code>ArrayList&lt;&gt;</code> は <code>ArrayList&lt;String&gt;</code> の略</li>
</ul>


<pre><code class="java">List&lt;int&gt; list = new ArrayList&lt;&gt;();
</code></pre>

<ul>
<li>要素の型に基本型は指定できない</li>
</ul>


<h2>リスト</h2>

<h3>リストの具象クラス</h3>

<ul>
<li>ArrayList</li>
<li>LinkedList</li>
</ul>


<h3>ArrayList</h3>

<ul>
<li>良い点

<ul>
<li>インデックスを指定して要素を読み出す速度が速い[get]</li>
<li>インデックスを指定して要素を書き換える速度が速い[set]</li>
<li>先頭から順にすべての要素をなめる処理が速い</li>
</ul>
</li>
<li>悪い点

<ul>
<li>要素の挿入が遅いことがある[add]

<ul>
<li>先頭に近い位置への挿入は遅い</li>
<li>末尾に近い位置への挿入は速いときもあるが遅いときもある</li>
</ul>
</li>
<li>要素の削除が遅いことがある[remove]

<ul>
<li>先頭に近い位置の削除ほど遅い</li>
<li>末尾に近い位置の削除ほど速い</li>
<li>最末尾の削除は高速</li>
</ul>
</li>
<li>条件に合致した要素の検索があまり速くない[contains, indexOf, lastIndexOf]</li>
</ul>
</li>
<li>要素の順序をもつので、順序が入れ替わる要素が多くなる処理は遅い</li>
<li>連続したメモリの確保ができない場合、末尾への挿入は遅くなる</li>
</ul>


<h3>LinkedList</h3>

<ul>
<li>良い点

<ul>
<li>要素の挿入が速い[add]</li>
<li>要素の削除が速い[remove]</li>
</ul>
</li>
<li>悪い点

<ul>
<li>インデックスを指定して要素を読み出す速度はあまり速くない[get]</li>
<li>インデックスを指定して要素を書き換える速度はあまり速くない[set]</li>
<li>条件に合致した要素を検索する処理の速度はあまり速くない[contains, indexOf, lastIndexOf]</li>
</ul>
</li>
<li>要素にたどり着くまでリンクをたどるのでリストの真ん中に近い要素ほどアクセスに時間がかかる</li>
</ul>


<h2>マップ</h2>

<pre><code class="java">Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
Map&lt;Integer, List&lt;String&gt;&gt; map = new TreeMap&lt;&gt;();
</code></pre>

<ul>
<li>Map インターフェースはキーと値の両方の型を <code>&lt;&gt;</code> の中に指定する</li>
<li>List インターフェース同様 <code>&lt;&gt;</code> に指定できるのは参照型のみ</li>
</ul>


<h3>マップの具象クラス</h3>

<ul>
<li>HashMap</li>
<li>LinkedHashMap</li>
<li>TreeMap</li>
</ul>


<h3>HashMap</h3>

<h4>HashMapの内部動作</h4>

<ul>
<li>HashMap は内部に配列を確保する。これをハッシュ表と呼ぶ。</li>
<li>ハッシュ表の初期サイズは HashMap のコンストラクタで指定する。</li>
<li>キーと値のペアを HashMap に追加[put]すると HashMap は内部でキーをハッシュ関数に通す。</li>
<li>ハッシュ関数の出力がハッシュ表のインデックスになる。</li>
<li>得られたインデックスの要素としてキーと値のペアを格納する。</li>
</ul>


<h3>LinkedHashMap</h3>

<h4>LinkedHashMapの内部動作</h4>

<ul>
<li>HashMap を拡張継承している</li>
<li>ハッシュ表に加えて、 LinkedList と同じリンクリストを内部に保持する</li>
<li>要素を追加すると内部でハッシュ表とリンクリストの両方に要素を追加する</li>
</ul>


<pre><code class="java">LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)
</code></pre>

<ul>
<li>上記コンストラクタの <code>accessOrder</code> に <code>true</code> を指定するとリンクリストの順序が要素にアクセスした順になる</li>
</ul>


<h3>TreeMap</h3>

<p>二分探索木の一種である赤黒木と呼ばれるアルゴリズムによるツリー構造で要素をもつ</p>

<h4>NavigableMap</h4>

<p>TreeMap がキーの順序をもつことを利用したインターフェース</p>

<pre><code class="java">public class Sample {
    public static void main(String... args) {
        NavigableMap&lt;String, String&gt; map = new TreeMap&lt;&gt;();
        map.put("kanayama", "one");
        map.put("kawai", "four");
        map.put("kushibiki", "five");

        Map.Entry&lt;String, String&gt; entry = map.ceilingEntry("kana");
        if (entry != null) {
            entry.getKey() + ": " + entry.getValue();  // "kanayama: one"
        }
    }
}
</code></pre>

<h2>セット</h2>

<ul>
<li>セットは数学の集合の概念</li>
<li>要素の重複を許さない</li>
<li>Set インターフェースを実装した具象クラスは以下の3つ

<ul>
<li>HashSet</li>
<li>LinkedHashSet</li>
<li>TreeSet</li>
</ul>
</li>
<li>要素の重複を許さない点が Map のキーの性質と重なるため、具象クラスも Map と重なる</li>
</ul>


<h2>スタック、キュー、デック</h2>

<ul>
<li>スタック: 最新要素から常に取り出し</li>
<li>キュー: 最古要素から常に取り出し</li>
<li>デック: 上記どちらにも対応</li>
<li>スタック構造は Deque クラス（Stack クラスは古い）</li>
<li>キュー構造は Queue クラス</li>
</ul>


<h2>イテレータ</h2>

<h3>拡張for構文</h3>

<pre><code class="java">for (要素型 ループ変数 : コレクション変数) {
    forループが回るたびにループ変数が要素オブジェクトを順に参照
}
</code></pre>

<h3>イテレータ</h3>

<ul>
<li>イテレーションを抽象化したオブジェクト</li>
<li>Iterator インターフェースは以下のメソッドをもつ

<ul>
<li><code>boolean</code> <code>hasNext();</code></li>
<li><code>E</code> <code>next();</code></li>
<li><code>void</code> <code>remove();</code></li>
</ul>
</li>
<li>ListIterator インターフェースは Iterator を継承している</li>
<li>ListIterator は上記に加えて以下の以下のメソッドをもつ

<ul>
<li><code>boolean</code> <code>hasPrevious();</code></li>
<li><code>E</code> <code>previous();</code></li>
</ul>
</li>
</ul>


<h3>例</h3>

<p>セットに対するイテレーション</p>

<pre><code class="java">// Set&lt;Integer&gt; set
for (Integer n : set) {
    sum += n;
}

for (Iterator&lt;Integer&gt; it = set.iterator(); it.hasNext(); ) {
    Integer n = it.next();
    sum += n;
}
</code></pre>

<p>マップに対するイテレーション</p>

<pre><code class="java">// Map&lt;String, String&gt; map

// 拡張 for でキーを繰り返す
for (String key : map.keySet()) {
    System.out.println(key);
}

// イテレータで値を繰り返す
for (Iterator&lt;String&gt; it = map.values().iterator(); it.hasNext(); ) {
    String val = it.next();
    System.out.println(val);
}

// 拡張 for でキーと値を繰り返す
for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) {
    System.out.println(entry.getKey());
    System.out.println(entry.getValue());
}
</code></pre>

<p>リストを逆順になめる</p>

<pre><code class="java">// List&lt;Integer&gt; list
for (ListIterator&lt;Integer&gt; it = list.listIterator(list.size()); it.hasPrevious(); ) {
    Integer i = it.previous();
    System.out.println(i);
}
</code></pre>

<h2>配列</h2>

<pre><code class="java">int[] arr = new int[3];

int[] arr = { 0, 1, 2 };
</code></pre>

<h3>多次元配列の初期化</h3>

<pre><code class="java">StringBuilder[][][] arr = {
    {
        { new StringBuilder("000"), new StringBuilder("001") },
        { new StringBuilder("010"), new StringBuilder("011") },
    },
    {
        { new StringBuilder("100"), new StringBuilder("101") },
        { new StringBuilder("110"), new StringBuilder("111") },
    },
};
</code></pre>

<h2>参照</h2>

<p><a href="http://www.amazon.co.jp/gp/product/4774166855/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=4774166855&amp;linkCode=as2&amp;tag=sojiro14-22">改訂2版 パーフェクトJava</a></p>
]]></content>
  </entry>
  
</feed>
