<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | Sojiro's Blog]]></title>
  <link href="http://sojiro14.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://sojiro14.github.io/"/>
  <updated>2016-08-24T03:14:01+09:00</updated>
  <id>http://sojiro14.github.io/</id>
  <author>
    <name><![CDATA[Sojiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[パーフェクトJava読書メモ Chapter 7 インターフェース]]></title>
    <link href="http://sojiro14.github.io/blog/2016/07/24/study-of-perfect-java-chapter-7/"/>
    <updated>2016-07-24T02:29:32+09:00</updated>
    <id>http://sojiro14.github.io/blog/2016/07/24/study-of-perfect-java-chapter-7</id>
    <content type="html"><![CDATA[<p>Javaを使うために<a href="http://www.amazon.co.jp/gp/product/4774166855/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=4774166855&amp;linkCode=as2&amp;tag=sojiro14-22">改訂2版 パーフェクトJava</a>を読んだメモ</p>

<h2>クラスとインターフェースの違い</h2>

<ul>
<li>インターフェースは雛形としての役割を持たない</li>
<li>インターフェースは実体化できず、型定義に特化している</li>
<li>インターフェースの継承の目的は多様性のみ（クラスの拡張継承には実装コードの共有という側面もある）</li>
</ul>


<h2>インターフェース宣言</h2>

<pre><code class="java">[修飾子] interface インターフェース名 {
    メンバ宣言
}
</code></pre>

<h3>インターフェースの修飾子</h3>

<table>
<thead>
<tr>
<th> modifier </th>
<th> description </th>
</tr>
</thead>
<tbody>
<tr>
<td> <code>public</code> </td>
<td> グローバルにアクセス可（書かないとパッケージ内に限定） </td>
</tr>
<tr>
<td> <code>abstract</code> </td>
<td> インターフェースは暗黙的に abstract なので書かなくても同じ </td>
</tr>
<tr>
<td> <code>strictfp</code> </td>
<td> インターフェース内に記述した浮動小数点演算を厳密に評価 </td>
</tr>
<tr>
<td> アノテーション </td>
<td> 省略 </td>
</tr>
</tbody>
</table>


<h3>インターフェースのメンバ</h3>

<ul>
<li>抽象メソッド（実装なし）</li>
<li>default メソッド</li>
<li>static メソッド</li>
<li>定数フィールド</li>
<li>static なネストしたクラス</li>
<li>static なネストしたインターフェース</li>
</ul>


<h3>メソッド宣言</h3>

<table>
<thead>
<tr>
<th> modifier </th>
<th> description </th>
</tr>
</thead>
<tbody>
<tr>
<td> <code>public</code> </td>
<td> 暗黙的に public なので書かなくても同じ</td>
</tr>
<tr>
<td> <code>default</code> </td>
<td> デフォルトメソッド </td>
</tr>
<tr>
<td> <code>static</code> </td>
<td> static メソッド </td>
</tr>
<tr>
<td> <code>abstract</code> </td>
<td> 暗黙的に abstract なので書かなくても同じ </td>
</tr>
</tbody>
</table>


<ul>
<li><code>default</code> メソッドはインスタンスメソッド</li>
<li>インターフェースを継承した具象クラスのインスタンスメソッドになる</li>
<li>フィールド変数は暗黙的に <code>public</code> <code>static</code> <code>final</code></li>
</ul>


<h2>インターフェースと実装クラス</h2>

<h3>インターフェース継承</h3>

<pre><code class="java">[修飾子] class クラス名 implements インターフェース名 {
    クラス本体
}
</code></pre>

<p>複数のインターフェースを同時に継承することができる</p>

<pre><code class="java">[修飾子] class クラス名 implements インターフェース名, インターフェース名 {
    クラス本体
}
</code></pre>

<ul>
<li>クラスの拡張継承とインターフェースの継承を同時にできる</li>
<li>このとき <code>implements</code> は <code>extends</code> より後に書く</li>
</ul>


<pre><code class="java">[修飾子] class クラス名 extends 親クラス名 implements インターフェース名 {
    クラス本体
}
</code></pre>

<ul>
<li>インターフェースを継承したクラスはインターフェースの抽象メソッドをすべてオーバーライドする必要がある</li>
<li>インターフェースから継承したメソッドのアクセス制御は <code>public</code> 修飾子がないとコンパイルエラー</li>
<li>メソッドのオーバーライドはクラスの拡張継承と同様に行う</li>
</ul>


<h3>ネストしたインターフェース</h3>

<ul>
<li>クラス内のネストしたインターフェース

<ul>
<li><code>public</code> <code>protected</code> 無指定 <code>private</code> のいずれかを指定する</li>
</ul>
</li>
<li>インターフェース内のネストしたインターフェース

<ul>
<li>常に <code>public</code></li>
</ul>
</li>
<li>インターフェース内のネストしたクラス

<ul>
<li>常に <code>public</code> かつ <code>static</code></li>
</ul>
</li>
<li>ネストして宣言されたインターフェースは常に <code>static</code></li>
</ul>


<h3>インターフェース自体の拡張継承</h3>

<ul>
<li>インターフェースも拡張継承できる</li>
<li>インターフェースは複数の親インターフェースを指定可能</li>
</ul>


<pre><code class="java">interface Parent {
    void print();
}

interface Child extends Parent {
    // void print() を継承
}

interface Father {
    void print();
}

interface Mother {
    void exec();
}

interface Child2 extends Father, Mother {
    // void print(), void exec() を継承
}
</code></pre>

<h2>参照</h2>

<p><a href="http://www.amazon.co.jp/gp/product/4774166855/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=4774166855&amp;linkCode=as2&amp;tag=sojiro14-22">改訂2版 パーフェクトJava</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[パーフェクトJava読書メモ Chapter 6 コレクションと配列]]></title>
    <link href="http://sojiro14.github.io/blog/2016/07/21/study-of-perfect-java-chapter-6/"/>
    <updated>2016-07-21T03:27:46+09:00</updated>
    <id>http://sojiro14.github.io/blog/2016/07/21/study-of-perfect-java-chapter-6</id>
    <content type="html"><![CDATA[<p>Javaを使うために<a href="http://www.amazon.co.jp/gp/product/4774166855/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=4774166855&amp;linkCode=as2&amp;tag=sojiro14-22">改訂2版 パーフェクトJava</a>を読んだメモ</p>

<h2>コレクションフレームワーク</h2>

<table>
<thead>
<tr>
<th> &mdash;&ndash; </th>
<th> Hash Table </th>
<th> Array      </th>
<th> Tree    </th>
<th> Linked List </th>
<th> Hash Table + Linked List </th>
</tr>
</thead>
<tbody>
<tr>
<td> set   </td>
<td> HashSet    </td>
<td> &mdash;        </td>
<td> TreeSet </td>
<td> &mdash;         </td>
<td> LinkedHashSet            </td>
</tr>
<tr>
<td> list  </td>
<td> &mdash;        </td>
<td> ArrayList  </td>
<td> &mdash;     </td>
<td> LinkedList  </td>
<td> &mdash;                      </td>
</tr>
<tr>
<td> deque </td>
<td> &mdash;        </td>
<td> ArrayDeque </td>
<td> &mdash;     </td>
<td> LinkedList  </td>
<td> &mdash;                      </td>
</tr>
<tr>
<td> map   </td>
<td> HashMap    </td>
<td> &mdash;        </td>
<td> TreeMap </td>
<td> &mdash;         </td>
<td> LinkedHashMap            </td>
</tr>
</tbody>
</table>


<h3>コレクション型オブジェクトの生成</h3>

<pre><code class="java">コレクションのインターフェース型&lt;要素の型&gt; 変数 = new コレクションのインターフェースを実装した具象クラス&lt;&gt;([コンストラクタの引数]);
</code></pre>

<pre><code class="java">List&lt;String&gt; list = new ArrayList&lt;&gt;();
</code></pre>

<ul>
<li>上記例で <code>ArrayList&lt;&gt;</code> は <code>ArrayList&lt;String&gt;</code> の略</li>
</ul>


<pre><code class="java">List&lt;int&gt; list = new ArrayList&lt;&gt;();
</code></pre>

<ul>
<li>要素の型に基本型は指定できない</li>
</ul>


<h2>リスト</h2>

<h3>リストの具象クラス</h3>

<ul>
<li>ArrayList</li>
<li>LinkedList</li>
</ul>


<h3>ArrayList</h3>

<ul>
<li>良い点

<ul>
<li>インデックスを指定して要素を読み出す速度が速い[get]</li>
<li>インデックスを指定して要素を書き換える速度が速い[set]</li>
<li>先頭から順にすべての要素をなめる処理が速い</li>
</ul>
</li>
<li>悪い点

<ul>
<li>要素の挿入が遅いことがある[add]

<ul>
<li>先頭に近い位置への挿入は遅い</li>
<li>末尾に近い位置への挿入は速いときもあるが遅いときもある</li>
</ul>
</li>
<li>要素の削除が遅いことがある[remove]

<ul>
<li>先頭に近い位置の削除ほど遅い</li>
<li>末尾に近い位置の削除ほど速い</li>
<li>最末尾の削除は高速</li>
</ul>
</li>
<li>条件に合致した要素の検索があまり速くない[contains, indexOf, lastIndexOf]</li>
</ul>
</li>
<li>要素の順序をもつので、順序が入れ替わる要素が多くなる処理は遅い</li>
<li>連続したメモリの確保ができない場合、末尾への挿入は遅くなる</li>
</ul>


<h3>LinkedList</h3>

<ul>
<li>良い点

<ul>
<li>要素の挿入が速い[add]</li>
<li>要素の削除が速い[remove]</li>
</ul>
</li>
<li>悪い点

<ul>
<li>インデックスを指定して要素を読み出す速度はあまり速くない[get]</li>
<li>インデックスを指定して要素を書き換える速度はあまり速くない[set]</li>
<li>条件に合致した要素を検索する処理の速度はあまり速くない[contains, indexOf, lastIndexOf]</li>
</ul>
</li>
<li>要素にたどり着くまでリンクをたどるのでリストの真ん中に近い要素ほどアクセスに時間がかかる</li>
</ul>


<h2>マップ</h2>

<pre><code class="java">Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
Map&lt;Integer, List&lt;String&gt;&gt; map = new TreeMap&lt;&gt;();
</code></pre>

<ul>
<li>Map インターフェースはキーと値の両方の型を <code>&lt;&gt;</code> の中に指定する</li>
<li>List インターフェース同様 <code>&lt;&gt;</code> に指定できるのは参照型のみ</li>
</ul>


<h3>マップの具象クラス</h3>

<ul>
<li>HashMap</li>
<li>LinkedHashMap</li>
<li>TreeMap</li>
</ul>


<h3>HashMap</h3>

<h4>HashMapの内部動作</h4>

<ul>
<li>HashMap は内部に配列を確保する。これをハッシュ表と呼ぶ。</li>
<li>ハッシュ表の初期サイズは HashMap のコンストラクタで指定する。</li>
<li>キーと値のペアを HashMap に追加[put]すると HashMap は内部でキーをハッシュ関数に通す。</li>
<li>ハッシュ関数の出力がハッシュ表のインデックスになる。</li>
<li>得られたインデックスの要素としてキーと値のペアを格納する。</li>
</ul>


<h3>LinkedHashMap</h3>

<h4>LinkedHashMapの内部動作</h4>

<ul>
<li>HashMap を拡張継承している</li>
<li>ハッシュ表に加えて、 LinkedList と同じリンクリストを内部に保持する</li>
<li>要素を追加すると内部でハッシュ表とリンクリストの両方に要素を追加する</li>
</ul>


<pre><code class="java">LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)
</code></pre>

<ul>
<li>上記コンストラクタの <code>accessOrder</code> に <code>true</code> を指定するとリンクリストの順序が要素にアクセスした順になる</li>
</ul>


<h3>TreeMap</h3>

<p>二分探索木の一種である赤黒木と呼ばれるアルゴリズムによるツリー構造で要素をもつ</p>

<h4>NavigableMap</h4>

<p>TreeMap がキーの順序をもつことを利用したインターフェース</p>

<pre><code class="java">public class Sample {
    public static void main(String... args) {
        NavigableMap&lt;String, String&gt; map = new TreeMap&lt;&gt;();
        map.put("kanayama", "one");
        map.put("kawai", "four");
        map.put("kushibiki", "five");

        Map.Entry&lt;String, String&gt; entry = map.ceilingEntry("kana");
        if (entry != null) {
            entry.getKey() + ": " + entry.getValue();  // "kanayama: one"
        }
    }
}
</code></pre>

<h2>セット</h2>

<ul>
<li>セットは数学の集合の概念</li>
<li>要素の重複を許さない</li>
<li>Set インターフェースを実装した具象クラスは以下の3つ

<ul>
<li>HashSet</li>
<li>LinkedHashSet</li>
<li>TreeSet</li>
</ul>
</li>
<li>要素の重複を許さない点が Map のキーの性質と重なるため、具象クラスも Map と重なる</li>
</ul>


<h2>スタック、キュー、デック</h2>

<ul>
<li>スタック: 最新要素から常に取り出し</li>
<li>キュー: 最古要素から常に取り出し</li>
<li>デック: 上記どちらにも対応</li>
<li>スタック構造は Deque クラス（Stack クラスは古い）</li>
<li>キュー構造は Queue クラス</li>
</ul>


<h2>イテレータ</h2>

<h3>拡張for構文</h3>

<pre><code class="java">for (要素型 ループ変数 : コレクション変数) {
    forループが回るたびにループ変数が要素オブジェクトを順に参照
}
</code></pre>

<h3>イテレータ</h3>

<ul>
<li>イテレーションを抽象化したオブジェクト</li>
<li>Iterator インターフェースは以下のメソッドをもつ

<ul>
<li><code>boolean</code> <code>hasNext();</code></li>
<li><code>E</code> <code>next();</code></li>
<li><code>void</code> <code>remove();</code></li>
</ul>
</li>
<li>ListIterator インターフェースは Iterator を継承している</li>
<li>ListIterator は上記に加えて以下の以下のメソッドをもつ

<ul>
<li><code>boolean</code> <code>hasPrevious();</code></li>
<li><code>E</code> <code>previous();</code></li>
</ul>
</li>
</ul>


<h3>例</h3>

<p>セットに対するイテレーション</p>

<pre><code class="java">// Set&lt;Integer&gt; set
for (Integer n : set) {
    sum += n;
}

for (Iterator&lt;Integer&gt; it = set.iterator(); it.hasNext(); ) {
    Integer n = it.next();
    sum += n;
}
</code></pre>

<p>マップに対するイテレーション</p>

<pre><code class="java">// Map&lt;String, String&gt; map

// 拡張 for でキーを繰り返す
for (String key : map.keySet()) {
    System.out.println(key);
}

// イテレータで値を繰り返す
for (Iterator&lt;String&gt; it = map.values().iterator(); it.hasNext(); ) {
    String val = it.next();
    System.out.println(val);
}

// 拡張 for でキーと値を繰り返す
for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) {
    System.out.println(entry.getKey());
    System.out.println(entry.getValue());
}
</code></pre>

<p>リストを逆順になめる</p>

<pre><code class="java">// List&lt;Integer&gt; list
for (ListIterator&lt;Integer&gt; it = list.listIterator(list.size()); it.hasPrevious(); ) {
    Integer i = it.previous();
    System.out.println(i);
}
</code></pre>

<h2>配列</h2>

<pre><code class="java">int[] arr = new int[3];

int[] arr = { 0, 1, 2 };
</code></pre>

<h3>多次元配列の初期化</h3>

<pre><code class="java">StringBuilder[][][] arr = {
    {
        { new StringBuilder("000"), new StringBuilder("001") },
        { new StringBuilder("010"), new StringBuilder("011") },
    },
    {
        { new StringBuilder("100"), new StringBuilder("101") },
        { new StringBuilder("110"), new StringBuilder("111") },
    },
};
</code></pre>

<h2>参照</h2>

<p><a href="http://www.amazon.co.jp/gp/product/4774166855/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=4774166855&amp;linkCode=as2&amp;tag=sojiro14-22">改訂2版 パーフェクトJava</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[パーフェクトJava読書メモ Chapter 5 クラス]]></title>
    <link href="http://sojiro14.github.io/blog/2016/07/20/study-of-perfect-java-chapter-5/"/>
    <updated>2016-07-20T08:40:03+09:00</updated>
    <id>http://sojiro14.github.io/blog/2016/07/20/study-of-perfect-java-chapter-5</id>
    <content type="html"><![CDATA[<p>Javaを使うために<a href="http://www.amazon.co.jp/gp/product/4774166855/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=4774166855&amp;linkCode=as2&amp;tag=sojiro14-22">改訂2版 パーフェクトJava</a>を読んだメモ</p>

<h2>オブジェクトの生成</h2>

<p>Javaのオブジェクト生成方法は以下の5つ</p>

<table>
<thead>
<tr>
<th> procedure   </th>
<th> description </th>
</tr>
</thead>
<tbody>
<tr>
<td> <code>new</code> 式 </td>
<td> 基本的な生成手段 </td>
</tr>
<tr>
<td> <code>String</code> リテラル及び結合演算式 </td>
<td> 文字列固有の手段 </td>
</tr>
<tr>
<td> オートボクシング </td>
<td> 数値クラス固有の手段 </td>
</tr>
<tr>
<td> リフレクション </td>
<td> フレームワークなどが下位に隠蔽すべき手段 </td>
</tr>
<tr>
<td> <code>clone</code> メソッド</td>
<td> <code>Object</code> クラスに実装された手段 </td>
</tr>
</tbody>
</table>


<h2>ファクトリパターン</h2>

<p><code>new</code> 式をファクトリメソッドに隠蔽することでオブジェクトの生成をコンストラクタから分離する
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">class</span> <span class="nc">Sample</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// コンストラクタへのアクセスを制限</span>
</span><span class='line'>    <span class="kd">private</span> <span class="nf">Sample</span><span class="o">()</span> <span class="o">{}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">// ファクトリメソッド</span>
</span><span class='line'><span class="kd">static</span> <span class="n">Sample</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Sample</span> <span class="n">sample</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Sample</span><span class="o">();</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">sample</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span></code></pre></td></tr></table></div></figure></p>

<ul>
<li>オブジェクトプーリング

<ul>
<li>オブジェクトの生成にコストがかかる場合、キャッシュされた生成済みオブジェクトを使う</li>
</ul>
</li>
<li>シングルトンパターン

<ul>
<li>オブジェクトの数を1つに制限する</li>
</ul>
</li>
</ul>


<h2>クラス宣言</h2>

<p>新しいクラスを定義するには次のように予約語 <code>class</code> を使う
<code>java
[修飾子] class クラス名 {
    メンバ宣言
      - フィールド宣言
      - メソッド宣言
      - ネストしたクラス宣言及びネストしたインターフェース宣言
    コンストラクタ宣言
    初期化ブロック
}
</code></p>

<h3>クラスの修飾子</h3>

<ul>
<li>クラス宣言時に指定できる修飾子は以下の5つ</li>
<li>複数同時指定可能（ただし <code>final</code> と <code>abstract</code> を同時に指定するとコンパイルエラー）</li>
</ul>


<table>
<thead>
<tr>
<th> modifier </th>
<th> description </th>
</tr>
</thead>
<tbody>
<tr>
<td> <code>public</code> </td>
<td> グローバルにアクセス可（書かないとパッケージ内に限定） </td>
</tr>
<tr>
<td> <code>final</code> </td>
<td> 継承禁止 </td>
</tr>
<tr>
<td> <code>abstract</code> </td>
<td> 抽象クラス </td>
</tr>
<tr>
<td> <code>strictfp</code> </td>
<td> クラス内に記述した浮動小数点演算を厳密に評価 </td>
</tr>
<tr>
<td> アノテーション </td>
<td> 省略 </td>
</tr>
</tbody>
</table>


<h2>フィールド</h2>

<h3>フィールド宣言の修飾子</h3>

<table>
<thead>
<tr>
<th> modifier </th>
<th> description </th>
</tr>
</thead>
<tbody>
<tr>
<td> <code>public</code> </td>
<td> アクセス制御 </td>
</tr>
<tr>
<td> <code>protected</code> </td>
<td> アクセス制御 </td>
</tr>
<tr>
<td> <code>private</code> </td>
<td> アクセス制御 </td>
</tr>
<tr>
<td> <code>final</code> </td>
<td> フィールド変数への再代入禁止 </td>
</tr>
<tr>
<td> <code>static</code> </td>
<td> クラスフィールド </td>
</tr>
<tr>
<td> <code>transient</code> </td>
<td> シリアライズの対象外 </td>
</tr>
<tr>
<td> <code>volatile</code> </td>
<td> スレッド間で変数の値を同期 </td>
</tr>
</tbody>
</table>


<ul>
<li><code>public</code> 、 <code>protected</code> 、 <code>private</code> は同時に指定不可</li>
<li><code>final</code> 、 <code>volatile</code> は同時に指定不可</li>
</ul>


<h3>フィールド変数のスコープ</h3>

<ul>
<li>宣言の位置にかかわらず同一クラス内のすべてのコンストラクタとメソッドから使える</li>
<li><p>コンストラクタ内、メソッド内以外の場所では宣言した行以降がスコープとなる
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">class</span> <span class="nc">Sample</span> <span class="o">{</span>
</span><span class='line'>  <span class="c1">// コンパイルエラー</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s</span><span class="o">;&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="c1">// コンパイルエラー</span>
</span><span class='line'>  <span class="o">{</span>
</span><span class='line'>      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="c1">// フィールド宣言</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">sample</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></p></li>
</ul>


<h3>this参照</h3>

<ul>
<li><code>this</code> 参照は明示的な宣言なしに使える、該当クラスのオブジェクトを参照する参照型変数</li>
<li>クラス内での変数名はフィールド変数よりローカル変数、パラメータ変数が優先される</li>
<li>これらの場合にフィールド変数を使う場合は <code>this</code> 参照を明示する</li>
</ul>


<pre><code class="java">class Sample {
    private final String s = "sample";

    void method (String s) {
        s; // パラメータ変数
        this.s; // フィールド変数
    }

    void method2 () {
        String s = "test 2";
        s; // ローカル変数
        this.s; // フィールド変数
    }
}
</code></pre>

<h2>メソッド</h2>

<h3>メソッド宣言の修飾子</h3>

<table>
<thead>
<tr>
<th> modifier </th>
<th> description </th>
</tr>
</thead>
<tbody>
<tr>
<td> <code>public</code> </td>
<td> アクセス制御 </td>
</tr>
<tr>
<td> <code>protected</code> </td>
<td> アクセス制御 </td>
</tr>
<tr>
<td> <code>private</code> </td>
<td> アクセス制御 </td>
</tr>
<tr>
<td> <code>abstract</code> </td>
<td> 抽象メソッド </td>
</tr>
<tr>
<td> <code>final</code> </td>
<td> オーバーライド不可 </td>
</tr>
<tr>
<td> <code>static</code> </td>
<td> クラスメソッド </td>
</tr>
<tr>
<td> <code>synchronized</code> </td>
<td> 同期のためのロック獲得 </td>
</tr>
<tr>
<td> <code>native</code> </td>
<td> ネイティヴメソッド </td>
</tr>
<tr>
<td> <code>strictfp</code> </td>
<td> 浮動小数点演算を厳密に評価 </td>
</tr>
</tbody>
</table>


<ul>
<li><code>public</code> 、 <code>protected</code> 、 <code>private</code> は同時に指定不可</li>
<li><code>abstract</code> は <code>static</code> 、 <code>final</code> 、 <code>synchronized</code> 、 <code>native</code> 、 <code>strictfp</code> と同時に指定不可</li>
</ul>


<h3>同一クラス内でのメソッドのスコープ</h3>

<ul>
<li>クラス内でメソッド宣言より前で有効</li>
<li>クラス内で <code>this</code> 参照を使った呼び出しも可能</li>
</ul>


<h3>他のクラスからのメソッド呼び出し</h3>

<ul>
<li>アクセス制御が許せば可能</li>
<li>オブジェクト参照に <code>.</code> メソッドアクセス修飾子を適用する</li>
</ul>


<h3>引数</h3>

<ul>
<li>メソッド定義のパラメータ変数を <em>仮引数</em></li>
<li>メソッド呼び出し時に渡すパラメータを <em>実引数</em></li>
<li>メソッドが呼ばれると仮引数に実引数が代入される（call by value）</li>
</ul>


<h4>可変長引数</h4>

<ul>
<li>メソッド宣言の引数定義でパラメータ変数の型に <code>...</code> を書く</li>
<li>任意の数の実引数で呼び出すことができる</li>
<li>このような引数を可変長引数という</li>
</ul>


<pre><code class="Java">class Sample {
    void exec (String... messages) {
        for (String s : messages) {
            System.out.println(s);
        }
    }
}

Sample sample = new Sample();
sample.exec();
sample.exec("hoge");
sample.exec("hoge", "fuga", "foo");
</code></pre>

<ul>
<li>内部的には配列として引数が渡る</li>
</ul>


<pre><code class="java">// 上記クラス定義と等価
class Sample {
    void exec (String[] messages) {
        for (String s : messages) {
            System.out.println(s);
        }
    }
}
</code></pre>

<h3>返り値</h3>

<ul>
<li><code>return</code> 文を使う</li>
<li><code>return</code> はどこにいくつ書いても良い</li>
<li><code>return</code> の後に実行されるような文を書くとコンパイルエラー</li>
<li><code>void</code> メソッドに <code>return</code> を書くとコンパイルエラー</li>
<li><code>return</code> が返す値が返り値の型に代入できないとコンパイルエラー</li>
</ul>


<h3>メソッド実行の終わり方</h3>

<ul>
<li><code>return</code> 文で抜ける</li>
<li><code>void</code> 型のメソッドを最後まで実行して抜ける</li>
<li>例外を投げて抜ける</li>
</ul>


<h3>メソッドのオーバーロード</h3>

<ul>
<li>同じ引数の並びで同名のメソッドの宣言はコンパイルエラー</li>
<li>引数の型が変わると同名でもコンパイル可能</li>
<li>これをメソッドのオーバーロードと呼ぶ</li>
</ul>


<h3>メソッドのシグネチャ</h3>

<ul>
<li>クラスの中でメソッドを一意に特定する情報をシグネチャと呼ぶ</li>
<li>メソッドのシグネチャは以下の2つ

<ul>
<li>メソッド名</li>
<li>引数の型の並び</li>
</ul>
</li>
</ul>


<h3>再帰呼び出し</h3>

<ul>
<li>メソッドが自分自身のメソッドを呼ぶこと</li>
<li>停止条件が必要</li>
</ul>


<h2>コンストラクタ</h2>

<h3>コンストラクタの宣言</h3>

<ul>
<li>オブジェクト生成時に呼ばれる</li>
<li>コンストラクタ名はクラス名と一致する</li>
<li>修飾子に書けるのは以下の3つ

<ul>
<li><code>public</code></li>
<li><code>protected</code></li>
<li><code>private</code></li>
</ul>
</li>
<li>コンストラクタはクラス名と同名のメソッドに見えるが言語仕様上は別物</li>
<li>コンストラクタ内に <code>return</code> 文を書くとコンパイルエラー</li>
<li>オブジェクトの初期化処理はコンストラクタにまとめるべき</li>
</ul>


<h3>this呼び出しとsuper呼び出し</h3>

<ul>
<li><code>this</code> 呼び出しでコンストラクタの共通化ができる</li>
</ul>


<pre><code class="java">class Sample {
    // フィールド宣言を省略

    Sample (String name, String label) {
        this(name, label, 10); // 下のコンストラクタ呼び出し
    }
    Sample (String name, String label, int level) {
        this.name = name;
        this.label = label;
        this.level = level;
    }
}
</code></pre>

<ul>
<li>継承したクラスから継承元のコンストラクタを <code>super</code> で呼び出す</li>
</ul>


<pre><code class="java">class SubSample extends Sample {
    private final String type;

    SubSample (String name, String label, int level, String type) {
        super(name, label, level); // Sample クラスのコンストラクタ呼び出し
        this.type = type;
    }
}
</code></pre>

<h3>デフォルトコンストラクタ</h3>

<ul>
<li>コンストラクタ宣言が書かれないクラスにはデフォルトコンストラクタが自動生成される</li>
<li>デフォルトコンストラクタの引数はなし、中身が空</li>
</ul>


<h3>オブジェクト初期化の順序</h3>

<ol>
<li>フィールド変数にデフォルト値代入</li>
<li>フィールド変数宣言時の初期化、初期化ブロックを上から順に実行</li>
<li>コンストラクタ呼び出し</li>
</ol>


<h2>staticメンバ</h2>

<ul>
<li><code>static</code> 修飾子がついたフィールド変数やメソッド</li>
<li>クラスメンバという</li>
<li><code>static</code> がつかないフィールド変数、メソッドはインスタンスメンバ</li>
<li>クラスメンバは実体がクラスにしかなく、オブジェクトはコピーを持たない</li>
<li>インスタンスフィールドとクラスフィールドは同じ名前空間（同名はつけられない）</li>
</ul>


<h2>継承</h2>

<ul>
<li>継承には実装の継承と振る舞いの継承の2つがある</li>
<li>振る舞いの継承は後出の「インターフェース」</li>
<li>実装の継承としての拡張継承は、あらかじめ意図して設計されたクラスからのみ行うべき</li>
</ul>


<h3>拡張継承の構文</h3>

<ul>
<li>クラス宣言時に <code>extends</code> を使って継承する</li>
<li><code>extends</code> のないクラス宣言は暗黙に <code>java.lang.Object</code> を継承する</li>
<li>Java のすべてのクラスは必ず <code>java.lang.Object</code> を直接的または間接的に継承する</li>
</ul>


<pre><code class="java">[修飾子] class クラス名 extends 基底クラス名 {
    クラス本体
}
</code></pre>

<ul>
<li>継承したクラスで継承元と同名のフィールド変数を宣言すると継承元のフィールド変数を隠蔽する</li>
<li>継承元にあるメソッドと同じシグネチャのメソッドを定義するとメソッドをオーバーライドする</li>
<li>メソッドをオーバーライドする条件

<ul>
<li>同じメソッド名</li>
<li>引数の数と型がすべて一致</li>
<li>返り値の型が一致、もしくは継承型</li>
<li><code>throws</code> 説の例外型が一致もしくは継承した例外型</li>
<li>アクセス制御が一致もしくはより緩い</li>
</ul>
</li>
</ul>


<h3>@Overrideアノテーション</h3>

<ul>
<li><code>@Override</code> というアノテーションをつけるとオーバーライドのミスに気づける</li>
</ul>


<pre><code class="java">Class Sample {
    void exec (CharSequence s) {
        System.out.println("sample:exec");
    }
}

Class SubSample extends Sample {
    @Override
    void exec (String s) {
        System.out.println("subSample:exec");
    }
}
</code></pre>

<h3>super参照</h3>

<ul>
<li>オーバーライドされた元メソッドに <code>private</code> 修飾子がついていなければオーバーライドしたメソッド内から <code>super</code> 参照を通じて元のメソッドを呼び出すことができる</li>
<li>隠蔽されたフィールド変数も同様</li>
</ul>


<h3>finalクラス</h3>

<ul>
<li><code>final</code> 修飾子がついたクラスを final クラスと呼ぶ</li>
<li>final クラスを継承元にして <code>extends</code> で拡張しようとするとコンパイルエラー</li>
</ul>


<h2>抽象クラスと抽象メソッド</h2>

<ul>
<li>抽象クラスはインスタンス化できないクラス</li>
<li><code>abstract</code> 修飾子をつけてクラス宣言すると抽象クラスになる</li>
<li>抽象クラスは何らかの具象クラスの基底クラスとなる（雛形の役割を担う）</li>
<li>メソッド修飾子として <code>abstract</code> をつけると抽象メソッドとなる</li>
<li>抽象メソッドはメソッド本体をもたない（オーバーライド前提）</li>
<li>抽象メソッドを一つでももつとそのクラスは抽象クラス</li>
</ul>


<h2>ネストしたクラス</h2>

<ul>
<li>あるクラスの下請けを担うクラスをヘルパークラスという</li>
<li>クラス内にクラスを宣言できる</li>
<li>ネストしたクラスをメンバクラスと呼ぶ</li>
<li>外側のクラスをエンクロージングクラスと呼ぶ</li>
</ul>


<h3>staticなネストしたクラス</h3>

<ul>
<li><code>static</code> 修飾子がついたネストしたクラス</li>
<li><code>private</code> 修飾子が指定されるとエンクロージングクラスの外から見えなくなる</li>
<li>エンクロージングクラスの <code>private</code> フィールドや <code>private</code> メソッドにアクセスできる</li>
<li>エンクロージングクラスもネストしたクラスの <code>private</code> フィールドや <code>private</code> メソッドにアクセスできる</li>
</ul>


<h3>内部クラス</h3>

<ul>
<li>非 <code>static</code> なネストしたクラスを内部クラスと呼ぶ</li>
<li>内部クラスのオブジェクトはエンクロージングオブジェクトへの参照を暗黙的にもつ</li>
<li>エンクロージングクラスのクラスメソッド内では内部クラスのオブジェクト生成ができない</li>
</ul>


<h3>ローカル内部クラス</h3>

<ul>
<li>ローカル内部クラスはメソッド内、コンストラクタ内、初期化ブロック内、 <code>if</code> 節などのブロック内で定義するクラス</li>
<li>ローカル内部クラスはブロックの外からはアクセスできない</li>
<li>クラスの実装をブロック内に隠蔽するときに使う</li>
</ul>


<h3>匿名クラス</h3>

<ul>
<li>匿名クラスにはクラス名がない</li>
<li>オブジェクト生成は以下の構文で行う</li>
</ul>


<pre><code class="java">new 基底型(実引数) {
    メソッド宣言とフィールド宣言の差分実装
}
</code></pre>

<ul>
<li>匿名クラスにはクラス名がないため、基底型名を <code>new</code> 演算子に渡し、基底型との差分実装を書き足す</li>
<li>匿名クラスを使う利点

<ul>
<li>コンストラクタが不要</li>
<li>オブジェクト作成が1つだけ</li>
</ul>
</li>
</ul>


<h2>参照</h2>

<p><a href="http://www.amazon.co.jp/gp/product/4774166855/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=4774166855&amp;linkCode=as2&amp;tag=sojiro14-22">改訂2版 パーフェクトJava</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[パーフェクトJava読書メモ Chapter 4 変数とオブジェクト]]></title>
    <link href="http://sojiro14.github.io/blog/2016/07/18/study-of-perfect-java-chapter-4/"/>
    <updated>2016-07-18T20:13:40+09:00</updated>
    <id>http://sojiro14.github.io/blog/2016/07/18/study-of-perfect-java-chapter-4</id>
    <content type="html"><![CDATA[<p>Javaを使うために<a href="http://www.amazon.co.jp/gp/product/4774166855/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=4774166855&amp;linkCode=as2&amp;tag=sojiro14-22">改訂2版 パーフェクトJava</a>を読んだメモ</p>

<h2>変数とオブジェクト</h2>

<ul>
<li>Javaの変数は以下の二つに分類される

<ul>
<li>基本型変数</li>
<li>参照型変数</li>
</ul>
</li>
<li>オブジェクトはある体系にそってデータを表すモノであり、名前を持たない</li>
</ul>


<h2>変数</h2>

<h3>参照型変数</h3>

<ul>
<li>C言語のポインタ型変数の値がメモリ上のアドレス値そのものであるのに対し、Javaの参照型変数の値はオブジェクトの位置情報を指し示す抽象的な「何か」である</li>
<li>参照型変数は名前を持ち、オブジェクトを参照することで扱いやすく橋渡しする</li>
<li>参照型変数自体に型があり以下の3種類、これは参照しているオブジェクトの型とは別

<ul>
<li>クラス型</li>
<li>配列型</li>
<li>インターフェース型</li>
</ul>
</li>
</ul>


<h3>基本型変数</h3>

<ul>
<li>基本型変数は値をそのまま保持する</li>
<li>基本型の種類は以下の8つ

<ul>
<li><code>boolean</code></li>
<li><code>byte</code></li>
<li><code>char</code></li>
<li><code>short</code></li>
<li><code>int</code></li>
<li><code>long</code></li>
<li><code>float</code></li>
<li><code>double</code></li>
</ul>
</li>
</ul>


<h3>変数の宣言</h3>

<ul>
<li>変数を使うには最初に変数を宣言する</li>
<li>変数宣言は最初に変数の型を書き、続けて変数名を書く
<code>java
StringBuilder sb;
</code></li>
<li>基本型変数の宣言時も型名を変数名の前に書く
<code>java
int i;
</code></li>
<li>同じスコープで同名の変数は宣言できない
<code>java
void method(int i) {
  int i;
}
// コンパイルエラー
</code></li>
</ul>


<h3>変数の初期化</h3>

<ul>
<li>変数は宣言時に初期化できる
<code>java
int i = 1;
</code></li>
<li>初期化しない場合の変数のデフォルト値は変数の型と種類に依存する</li>
</ul>


<h3>変数の修飾子</h3>

<ul>
<li>変数の宣言時に修飾子を付けることができる</li>
<li>変数に使える修飾子は以下

<ul>
<li><code>private</code></li>
<li><code>protected</code></li>
<li><code>public</code></li>
<li><code>transient</code></li>
<li><code>final</code></li>
<li><code>static</code></li>
<li><code>volatile</code></li>
</ul>
</li>
</ul>


<h2>オブジェクト</h2>

<h3>オブジェクトの生成</h3>

<ul>
<li><code>new</code> の後にクラス名を書き、 <code>()</code> で引数を指定する</li>
<li>引数の定義はクラスごとに決まっている
<code>java
new StringBuilder("012");
</code></li>
</ul>


<h3>参照型変数への代入</h3>

<ul>
<li>生成したオブジェクトは参照型変数へ参照を渡して扱う
<code>java
StringBuilder sb = new StringBuilder();
</code></li>
<li>あくまで変数が扱っているのはオブジェクトへの参照なので、以下の例では2つの変数は同じオブジェクトへの参照を持つ
<code>java
StringBuilder sb = new StringBuilder();
StringBuilder sb2 = sb;
sb.append("012");
sb2.append("345");
// sb: "0123445"
// sb2: "012345"
</code></li>
</ul>


<h3>基本型変数への代入</h3>

<ul>
<li>基本型変数へ代入されるのはオブジェクトの参照ではなく値そのもの</li>
<li>値そのものをコピーして代入する
<code>java
int i = 42;
int j = i + 1;
int K = i;
// i: 42
// j: 43
// k: 42
</code></li>
</ul>


<h3>null参照</h3>

<ul>
<li><code>null</code> は「何も参照していない」ということを表す
<code>java
StringBuilder sb = null;
</code></li>
</ul>


<h4>nullチェック</h4>

<ul>
<li>参照先がなく、 <code>null</code> を持つ参照型変数にたいする演算は <code>NullPointerException</code></li>
<li><code>Object</code> クラスに <code>null</code> をチェックするためのメソッドがある</li>
</ul>


<table>
<thead>
<tr>
<th> method </th>
<th> description </th>
</tr>
</thead>
<tbody>
<tr>
<td> <code>equals</code> </td>
<td> 引数のどちらかが <code>null</code> でも使える比較 </td>
</tr>
<tr>
<td> <code>toString</code> </td>
<td> <code>null</code> の場合の文字列を指定可能 </td>
</tr>
<tr>
<td> <code>isNull</code> </td>
<td> 引数が <code>null</code> のとき真 </td>
</tr>
<tr>
<td> <code>notNull</code> </td>
<td> 引数が <code>null</code> でないとき真 </td>
</tr>
<tr>
<td> <code>requireNonNull</code> </td>
<td> 引数が <code>null</code> だと即座に <code>NullPointerException</code> </td>
</tr>
</tbody>
</table>


<h3>Optional型</h3>

<ul>
<li><code>Optional</code> 型は任意のオブジェクトをくるんで <code>null</code> かもしれない状態を表現する</li>
<li>基本型変数のための <code>Optional</code> 型として以下の 3 つがある

<ul>
<li><code>OptionalInt</code></li>
<li><code>OptionalLong</code></li>
<li><code>OptionalDouble</code></li>
</ul>
</li>
<li><code>Optional</code> オブジェクトは <code>of</code> または <code>ofNullable</code> メソッドを使って任意のオブジェクトから生成できる
<code>java
StringBuilder sb;
Optional&lt;StringBuilder&gt; osb = Optional.of(sb);
// or
// Oprional&lt;StringBuilder&gt; osb = Optional.ofNullable(sb);
</code></li>
<li><code>get</code> メソッドで <code>Optional</code> オブジェクトでくるんだオブジェクトを取得
<code>java
Optional&lt;StringBuilder&gt; osb;
StringBuilder sb = osb.get();
</code></li>
<li>くるんだオブジェクトが <code>null</code> でなければそのまま呼び出し、 <code>null</code> であれば引数のオブジェクトを返す例
<code>java
StringBuilder sb = osb.orElse(new StringBuilder("none"));
</code></li>
</ul>


<h3>変数を介さないオブジェクトの操作</h3>

<ul>
<li>変数に参照を格納しなくてもオブジェクトを操作できる
<code>java
int len = new StringBuilder("012").length();
</code></li>
<li>文字列リテラルでも
<code>java
int len = "abc".length();
</code></li>
<li>ドット演算子でメソッド呼び出しをつなげることをメソッドチェインという
<code>java
StringBuilder sb = new StringBuilder();
int len = sb.append("012").append("345").length();
// len: 6
</code></li>
</ul>


<h2>変数と型</h2>

<ul>
<li>オブジェクトの型はクラスで定義されている</li>
<li>変数の型とオブジェクトの型が一致もしくはオブジェクトの型が変数の型の下位型であるとき変数にオブジェクトの参照を代入可能</li>
<li>変数が参照するオブジェクトに対して行える操作は変数の型できまる</li>
<li>下位型のオブジェクトは上位型の持つメソッドを持つことが保証されている

<ul>
<li>ただし実態が同一とは限らない</li>
</ul>
</li>
</ul>


<h2>変数の詳細</h2>

<h3>変数の種類</h3>

<table>
<thead>
<tr>
<th> type </th>
<th> description </th>
</tr>
</thead>
<tbody>
<tr>
<td> ローカル変数 </td>
<td> メソッドもしくはコンストラクタ内で宣言される。メソッドやコンストラクタが終わると消滅。 </td>
</tr>
<tr>
<td> パラメータ変数 </td>
<td> メソッドもしくはコンストラクタに引数として渡る。メソッドやコンストラクタが終わると消滅。 </td>
</tr>
<tr>
<td> インスタンスフィールド変数 </td>
<td> クラスの構成要素 </td>
</tr>
<tr>
<td> クラスフィールド変数 </td>
<td> クラスの構成要素 </td>
</tr>
</tbody>
</table>


<h3>変数のデフォルト値</h3>

<table>
<thead>
<tr>
<th> type </th>
<th> default value </th>
</tr>
</thead>
<tbody>
<tr>
<td> 参照型 </td>
<td> <code>null</code>      </td>
</tr>
<tr>
<td> <code>boolean</code> </td>
<td> <code>false</code>  </td>
</tr>
<tr>
<td> <code>char</code> </td>
<td> &ldquo;¥u0000&rdquo;    </td>
</tr>
<tr>
<td> <code>byte</code>, <code>short</code>, <code>int</code>, <code>Long</code> </td>
<td> 0 </td>
</tr>
<tr>
<td> <code>float</code>, <code>double</code> </td>
<td> +0.0 </td>
</tr>
</tbody>
</table>


<h3>変数のスコープ</h3>

<h4>ローカル変数</h4>

<ul>
<li>変数を宣言した行からメソッドもしくはコンストラクタが終わるまで</li>
</ul>


<h4>ブロックスコープ</h4>

<ul>
<li><code>{}</code> で囲ったブロックに閉じたスコープ</li>
<li>変数を宣言した行からブロックが終わるまで</li>
</ul>


<h4>シャドーイング</h4>

<ul>
<li>同一のスコープ内で同じ変数を2度以上宣言</li>
</ul>


<h4>パラメータ変数のスコープ</h4>

<ul>
<li>メソッド及びコンストラクタの中</li>
</ul>


<h4>フィールド変数のスコープ</h4>

<ul>
<li>フィールド変数のスコープはクラス内</li>
<li>宣言した行の位置は無関係</li>
</ul>


<h2>オブジェクトの寿命</h2>

<p>オブジェクトへの参照が外れる条件
* ローカル変数及びパラメータ変数のスコープが外れたとき
* オブジェクトが消滅したとき
* クラスが消滅し、クラスフィールド変数の参照が外れたとき
* 変数に別のオブジェクトの参照もしくは <code>null</code> が再代入されたとき
* 変数を介さない操作がされていた場合、式の評価が終わったとき</p>

<h2>final変数と不変オブジェクト</h2>

<ul>
<li><code>final</code> 修飾子を指定した変数を final 変数と呼ぶ</li>
<li>final 変数は再代入不可</li>
<li><code>final</code> 修飾子が禁止するのは変数自体の値の変更であって、変数が参照するオブジェクト自体の変更ではない</li>
</ul>


<h2>参照</h2>

<p><a href="http://www.amazon.co.jp/gp/product/4774166855/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=4774166855&amp;linkCode=as2&amp;tag=sojiro14-22">改訂2版 パーフェクトJava</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[パーフェクトJava読書メモ Chapter 3 数値①]]></title>
    <link href="http://sojiro14.github.io/blog/2016/07/17/study-of-perfect-java-chapter-3/"/>
    <updated>2016-07-17T17:36:05+09:00</updated>
    <id>http://sojiro14.github.io/blog/2016/07/17/study-of-perfect-java-chapter-3</id>
    <content type="html"><![CDATA[<p>Javaを使うために<a href="http://www.amazon.co.jp/gp/product/4774166855/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=4774166855&amp;linkCode=as2&amp;tag=sojiro14-22">改訂2版 パーフェクトJava</a>を読んだメモ</p>

<h2>整数型</h2>

<p>以下の5種類</p>

<table>
<thead>
<tr>
<th> name   </th>
<th> bit length </th>
<th>  min  </th>
<th>  max  </th>
</tr>
</thead>
<tbody>
<tr>
<td> <code>byte</code>  </td>
<td> 8         </td>
<td> -128  </td>
<td>  127  </td>
</tr>
<tr>
<td> <code>char</code>  </td>
<td> 16        </td>
<td> 0     </td>
<td> 65535 </td>
</tr>
<tr>
<td> <code>short</code> </td>
<td> 16        </td>
<td> -32768 </td>
<td> 32767 </td>
</tr>
<tr>
<td> <code>int</code>   </td>
<td> 32        </td>
<td> -2147483648 </td>
<td> 2147483647 </td>
</tr>
<tr>
<td> <code>long</code>  </td>
<td> 64        </td>
<td> -9223372036854775808 </td>
<td> 9223372036854775807 </td>
</tr>
</tbody>
</table>


<h3>bit値</h3>

<p>符号あり整数で最上位ビットが1の値は負の値となる</p>

<h4>4bit長の符号なし整数</h4>

<table>
<thead>
<tr>
<th> type </th>
<th> value </th>
<th> bit </th>
</tr>
</thead>
<tbody>
<tr>
<td> min  </td>
<td> 0     </td>
<td> 0000 </td>
</tr>
<tr>
<td> max  </td>
<td> 15    </td>
<td> 1111 </td>
</tr>
</tbody>
</table>


<h4>4bit長の符号あり整数</h4>

<table>
<thead>
<tr>
<th> type      </th>
<th> value </th>
<th> bit </th>
</tr>
</thead>
<tbody>
<tr>
<td> min bit   </td>
<td> 0     </td>
<td> 0000 </td>
</tr>
<tr>
<td> max value </td>
<td> 7     </td>
<td> 0111 </td>
</tr>
<tr>
<td> min value </td>
<td> -8    </td>
<td> 1000 </td>
</tr>
<tr>
<td> max bit   </td>
<td> -1    </td>
<td> 1111 </td>
</tr>
</tbody>
</table>


<h2>桁あふれ</h2>

<p>整数の加算はbit値を進める処理であり、</p>

<p>整数の減算はbit値を戻す処理である</p>

<p>したがってbitの境界値をまたいで整数の加算減算を行うと予期しない結果となる場合がある
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">Interger</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
</span><span class='line'><span class="c1">// i: 2147483647&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">i</span><span class="o">++</span>
</span><span class='line'><span class="c1">// i: -2147483648</span>
</span></code></pre></td></tr></table></div></figure></p>

<h2>整数リテラル</h2>

<ul>
<li><code>L</code> または <code>l</code> で終わる整数リテラルの型は <code>long</code> 型</li>
<li>それ以外の整数リテラルは <code>int</code> 型</li>
<li><code>int</code> 型リテラル値を <code>byte</code> 、 <code>char</code> 、 <code>short</code> の型の変数に代入する場合、値が代入する先の型の範囲内であれば自動的に型が変換されて代入される

<ul>
<li>代入する先の型の範囲を超えている場合はコンパイルエラーとなる</li>
</ul>
</li>
</ul>


<h3>基数</h3>

<ul>
<li><code>0b</code> から始めると 2 進数</li>
<li><code>0</code> から始めると 8 進数</li>
<li><code>0x</code> から始めると 16 進数</li>
</ul>


<h2>整数の演算</h2>

<h3>四則演算</h3>

<table>
<thead>
<tr>
<th> 演算子 </th>
<th> 演算 </th>
</tr>
</thead>
<tbody>
<tr>
<td> +     </td>
<td> 和   </td>
</tr>
<tr>
<td> -     </td>
<td> 差   </td>
</tr>
<tr>
<td> *     </td>
<td> 積   </td>
</tr>
<tr>
<td> /     </td>
<td> 商   </td>
</tr>
</tbody>
</table>


<h4>注意点</h4>

<ul>
<li>大きな正の整数の和における桁あふれ</li>
<li>小さな負の整数の差における桁あふれ</li>
<li>絶対値の大きな整数同士の積の桁あふれ</li>
<li>商の結果は切り捨て</li>
<li>0 による割り算は <code>ArithmeticException</code></li>
</ul>


<h3>剰余</h3>

<ul>
<li>剰余演算子は <code>%</code></li>
<li>0 による剰余演算は <code>ArithmeticException</code></li>
</ul>


<h3>符号反転</h3>

<p>単項演算子 <code>-</code> は通常単純に符号を反転させる
<code>java
int n = 10;
// -n: -10
</code></p>

<p>しかしここにも桁あふれの問題があるので注意
<code>java
int n = -2147483648;
// -n: -2147483648
</code>
<a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.15.4">仕様書</a>によると</p>

<blockquote><p>-x equals (~x)+1</p></blockquote>

<ul>
<li><code>~</code> は bit 反転演算子</li>
<li>-2147483648 は bit に変換すると 100&hellip;0（0 が 31 個つづく）</li>
<li>これを反転させると 011&hellip;1（1 が 31 個つづく）となり、これは 2147483647 を表す</li>
<li>2147483647 + 1 は桁あふれが起こり、 -2147483648 となる</li>
</ul>


<h3>インクリメント・デクリメント</h3>

<ul>
<li><code>++</code> でインクリメント</li>
<li><code>--</code> でデクリメント</li>
</ul>


<h2>キャスト</h2>

<p><code>()</code> 付きで型を書くことで強制的に型変換する
<code>java
int i = 1;
short si = (short)i;
</code></p>

<h3>代入先の型に収まらないとあふれたbitが切り捨てられる</h3>

<pre><code class="java">short si = (short)65536;
// si: 0
</code></pre>

<ul>
<li>65536 は bit に変換すると 100&hellip;0 （0 が 16 個つづく）</li>
<li><code>short</code> 型は 16 bit なので先頭の 1 があふれる</li>
</ul>


<h2>ブーリアン（真偽値）</h2>

<p>ブーリアン型が取りうる値は <code>true</code> か <code>false</code> のみ</p>

<p>※ ド・モルガンの法則の説明等</p>

<h2>参照</h2>

<ul>
<li><a href="http://www.amazon.co.jp/gp/product/4774166855/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=4774166855&amp;linkCode=as2&amp;tag=sojiro14-22">改訂2版 パーフェクトJava</a></li>
<li><a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.15.4">15.15.4. Unary Minus Operator -</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
