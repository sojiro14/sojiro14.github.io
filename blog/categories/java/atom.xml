<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | Sojiro's Blog]]></title>
  <link href="http://sojiro14.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://sojiro14.github.io/"/>
  <updated>2016-07-22T08:50:16+09:00</updated>
  <id>http://sojiro14.github.io/</id>
  <author>
    <name><![CDATA[Sojiro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[パーフェクトJava読書メモ Chapter 3 数値①]]></title>
    <link href="http://sojiro14.github.io/blog/2016/07/17/study-of-perfect-java-chapter-3/"/>
    <updated>2016-07-17T17:36:05+09:00</updated>
    <id>http://sojiro14.github.io/blog/2016/07/17/study-of-perfect-java-chapter-3</id>
    <content type="html"><![CDATA[<p>Javaを使うために<a href="http://www.amazon.co.jp/gp/product/4774166855/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=4774166855&amp;linkCode=as2&amp;tag=sojiro14-22">改訂2版 パーフェクトJava</a>を読んだメモ</p>

<h2>整数型</h2>

<p>以下の5種類</p>

<table>
<thead>
<tr>
<th> name   </th>
<th> bit length </th>
<th>  min  </th>
<th>  max  </th>
</tr>
</thead>
<tbody>
<tr>
<td> <code>byte</code>  </td>
<td> 8         </td>
<td> -128  </td>
<td>  127  </td>
</tr>
<tr>
<td> <code>char</code>  </td>
<td> 16        </td>
<td> 0     </td>
<td> 65535 </td>
</tr>
<tr>
<td> <code>short</code> </td>
<td> 16        </td>
<td> -32768 </td>
<td> 32767 </td>
</tr>
<tr>
<td> <code>int</code>   </td>
<td> 32        </td>
<td> -2147483648 </td>
<td> 2147483647 </td>
</tr>
<tr>
<td> <code>long</code>  </td>
<td> 64        </td>
<td> -9223372036854775808 </td>
<td> 9223372036854775807 </td>
</tr>
</tbody>
</table>


<h3>bit値</h3>

<p>符号あり整数で最上位ビットが1の値は負の値となる</p>

<h4>4bit長の符号なし整数</h4>

<table>
<thead>
<tr>
<th> type </th>
<th> value </th>
<th> bit </th>
</tr>
</thead>
<tbody>
<tr>
<td> min  </td>
<td> 0     </td>
<td> 0000 </td>
</tr>
<tr>
<td> max  </td>
<td> 15    </td>
<td> 1111 </td>
</tr>
</tbody>
</table>


<h4>4bit長の符号あり整数</h4>

<table>
<thead>
<tr>
<th> type      </th>
<th> value </th>
<th> bit </th>
</tr>
</thead>
<tbody>
<tr>
<td> min bit   </td>
<td> 0     </td>
<td> 0000 </td>
</tr>
<tr>
<td> max value </td>
<td> 7     </td>
<td> 0111 </td>
</tr>
<tr>
<td> min value </td>
<td> -8    </td>
<td> 1000 </td>
</tr>
<tr>
<td> max bit   </td>
<td> -1    </td>
<td> 1111 </td>
</tr>
</tbody>
</table>


<h2>桁あふれ</h2>

<p>整数の加算はbit値を進める処理であり、</p>

<p>整数の減算はbit値を戻す処理である</p>

<p>したがってbitの境界値をまたいで整数の加算減算を行うと予期しない結果となる場合がある
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">Interger</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
</span><span class='line'><span class="c1">// i: 2147483647&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">i</span><span class="o">++</span>
</span><span class='line'><span class="c1">// i: -2147483648</span>
</span></code></pre></td></tr></table></div></figure></p>

<h2>整数リテラル</h2>

<ul>
<li><code>L</code> または <code>l</code> で終わる整数リテラルの型は <code>long</code> 型</li>
<li>それ以外の整数リテラルは <code>int</code> 型</li>
<li><code>int</code> 型リテラル値を <code>byte</code> 、 <code>char</code> 、 <code>short</code> の型の変数に代入する場合、値が代入する先の型の範囲内であれば自動的に型が変換されて代入される

<ul>
<li>代入する先の型の範囲を超えている場合はコンパイルエラーとなる</li>
</ul>
</li>
</ul>


<h3>基数</h3>

<ul>
<li><code>0b</code> から始めると 2 進数</li>
<li><code>0</code> から始めると 8 進数</li>
<li><code>0x</code> から始めると 16 進数</li>
</ul>


<h2>整数の演算</h2>

<h3>四則演算</h3>

<table>
<thead>
<tr>
<th> 演算子 </th>
<th> 演算 </th>
</tr>
</thead>
<tbody>
<tr>
<td> +     </td>
<td> 和   </td>
</tr>
<tr>
<td> -     </td>
<td> 差   </td>
</tr>
<tr>
<td> *     </td>
<td> 積   </td>
</tr>
<tr>
<td> /     </td>
<td> 商   </td>
</tr>
</tbody>
</table>


<h4>注意点</h4>

<ul>
<li>大きな正の整数の和における桁あふれ</li>
<li>小さな負の整数の差における桁あふれ</li>
<li>絶対値の大きな整数同士の積の桁あふれ</li>
<li>商の結果は切り捨て</li>
<li>0 による割り算は <code>ArithmeticException</code></li>
</ul>


<h3>剰余</h3>

<ul>
<li>剰余演算子は <code>%</code></li>
<li>0 による剰余演算は <code>ArithmeticException</code></li>
</ul>


<h3>符号反転</h3>

<p>単項演算子 <code>-</code> は通常単純に符号を反転させる
<code>java
int n = 10;
// -n: -10
</code></p>

<p>しかしここにも桁あふれの問題があるので注意
<code>java
int n = -2147483648;
// -n: -2147483648
</code>
<a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.15.4">仕様書</a>によると</p>

<blockquote><p>-x equals (~x)+1</p></blockquote>

<ul>
<li><code>~</code> は bit 反転演算子</li>
<li>-2147483648 は bit に変換すると 100&hellip;0（0 が 31 個つづく）</li>
<li>これを反転させると 011&hellip;1（1 が 31 個つづく）となり、これは 2147483647 を表す</li>
<li>2147483647 + 1 は桁あふれが起こり、 -2147483648 となる</li>
</ul>


<h3>インクリメント・デクリメント</h3>

<ul>
<li><code>++</code> でインクリメント</li>
<li><code>--</code> でデクリメント</li>
</ul>


<h2>キャスト</h2>

<p><code>()</code> 付きで型を書くことで強制的に型変換する
<code>java
int i = 1;
short si = (short)i;
</code></p>

<h3>代入先の型に収まらないとあふれたbitが切り捨てられる</h3>

<pre><code class="java">short si = (short)65536;
// si: 0
</code></pre>

<ul>
<li>65536 は bit に変換すると 100&hellip;0 （0 が 16 個つづく）</li>
<li><code>short</code> 型は 16 bit なので先頭の 1 があふれる</li>
</ul>


<h2>ブーリアン（真偽値）</h2>

<p>ブーリアン型が取りうる値は <code>true</code> か <code>false</code> のみ</p>

<p>※ ド・モルガンの法則の説明等</p>

<h2>参照</h2>

<ul>
<li><a href="http://www.amazon.co.jp/gp/product/4774166855/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=4774166855&amp;linkCode=as2&amp;tag=sojiro14-22">改訂2版 パーフェクトJava</a></li>
<li><a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.15.4">15.15.4. Unary Minus Operator -</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[パーフェクトJava読書メモ Chapter 2 文字と文字列]]></title>
    <link href="http://sojiro14.github.io/blog/2016/07/12/study-of-perfect-java-chapter-2/"/>
    <updated>2016-07-12T16:17:33+09:00</updated>
    <id>http://sojiro14.github.io/blog/2016/07/12/study-of-perfect-java-chapter-2</id>
    <content type="html"><![CDATA[<p>Javaを使うために<a href="http://www.amazon.co.jp/gp/product/4774166855/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=4774166855&amp;linkCode=as2&amp;tag=sojiro14-22">改訂2版 パーフェクトJava</a>を読んだメモ</p>

<h2>文字列</h2>

<p>&ldquo;（ダブルクォート）で囲んで文字数リテラル</p>

<h3>String クラス</h3>

<ul>
<li>文字列リテラルから <code>String</code> オブジェクトが自動生成</li>
<li>配列のように1文字ごとにindexが振られる</li>
</ul>


<h3>StringBuilder クラス</h3>

<ul>
<li>オブジェクトに対して破壊的</li>
<li><code>String</code> オブジェクトは read only</li>
</ul>


<h3>文字列の結合</h3>

<ul>
<li><code>+=</code> と <code>StringBuilder</code> の関係</li>
<li><code>join</code> メソッド</li>
</ul>


<h3>文字列の比較</h3>

<ul>
<li><code>==</code> 演算子じゃなくて <code>equals</code> メソッド

<ul>
<li><code>==</code> 比較は同一のオブジェクトへの参照かどうかの比較</li>
</ul>
</li>
<li>同じ文字列リテラルは同じ <code>String</code> オブジェクト</li>
<li>ただし <code>String</code> と <code>StringBuilder</code> では文字列の内容が同じでも違うオブジェクト

<ul>
<li>そんなときは <code>contentEquals</code> メソッド</li>
</ul>
</li>
<li><code>StringBuilder</code> 同士の文字列の内容比較もできないので、 <code>toString</code> で <code>String</code> に変換してから <code>contentEquals</code> 使うこと</li>
</ul>


<h3>文字列と数値の変換</h3>

<h4>数値から文字列への変換</h4>

<p><code>valueOf</code> メソッド
<code>java
String s = String.valueOf(255);
// s: "255"
</code></p>

<p><code>toString</code> メソッドで10進数以外に直接変換する
<code>java
String s = Integer.toString(255, 16);
// s: "ff"
</code></p>

<h3>文字列から数値への変換</h3>

<p><code>parseInt</code> メソッド
<code>java
int i = Integer.parseInt("255");
// i: 255
</code>
基数を与えて10進数以外の処理
<code>java
int i = Integer.parseint("ff", 16);
// i: 255
</code></p>

<h2>文字</h2>

<ul>
<li>&lsquo;（シングルクォート）で囲んで文字リテラル</li>
<li>Javaの世界ではUTF-16

<ul>
<li>文字を16bitの数値で表す <code>char</code> 型</li>
</ul>
</li>
<li>文字リテラルは <code>char</code> 型の数値</li>
<li><code>String</code> オブジェクトは文字（ <code>char</code> 型）の配列</li>
</ul>


<h2>バイト</h2>

<ul>
<li>歴史的に文字とバイトは同一視されがち</li>
<li>Javaではバイトを文字と区別する</li>
<li>8bit長の <code>byte</code> 型</li>
<li>バイト列は <code>byte</code> 型の配列</li>
</ul>


<h3>バイト列と文字列の変換</h3>

<h4>バイト列から文字列への変換</h4>

<p><code>byte</code> の配列を渡して <code>String</code> オブジェクトを生成
<code>java
byte[] bytes = new byte[]{0x61, 0x62, 0x63};
String s = new String(bytes);
// s: abc
</code></p>

<h4>文字列からバイト列への変換</h4>

<p><code>getBytes</code> メソッドを使う
<code>java
String s = "abc";
byte[] bytes = s.getBytes();
</code></p>

<h2>参照</h2>

<p><a href="http://www.amazon.co.jp/gp/product/4774166855/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=4774166855&amp;linkCode=as2&amp;tag=sojiro14-22">改訂2版 パーフェクトJava</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android StudioからGAE for Javaアプリケーションをdeployするのに必要なFacet]]></title>
    <link href="http://sojiro14.github.io/blog/2016/07/07/facets-necessary-in-order-to-deploy-from-android-studio-to-gae/"/>
    <updated>2016-07-07T08:27:00+09:00</updated>
    <id>http://sojiro14.github.io/blog/2016/07/07/facets-necessary-in-order-to-deploy-from-android-studio-to-gae</id>
    <content type="html"><![CDATA[<p><a href="http://qiita.com/okitsutakatomo/items/18cdd3db35185a9b1e99">こちらの記事</a>を参考にGAE for JavaアプリケーションをAndroid Studio + Gradleでセットアップし、サンプルアプリケーションを開発してみました。</p>

<p>早速GAEにdeployしてみようと、メニューバーの <code>Build</code> から <code>Deploy Module to App Engine...</code> を選択してdeployを実行&hellip;ところがタスクが走らずうんともすんとも言わないので調べてみました。</p>

<h2>結論</h2>

<p>以下の設定を <code>app.iml</code> ファイルに追記する</p>

<pre><code class="xml">&lt;facet type="android-gradle" name="Android-Gradle"&gt;
  &lt;configuration&gt;
    &lt;option name="GRADLE_PROJECT_PATH" value=":app" /&gt;
  &lt;/configuration&gt;
&lt;/facet&gt;
&lt;facet type="java-gradle" name="Java-Gradle"&gt;
  &lt;configuration&gt;
     &lt;option name="BUILD_FOLDER_PATH" value="$MODULE_DIR$/build" /&gt;
     &lt;option name="BUILDABLE" value="true" /&gt;
  &lt;/configuration&gt;
&lt;/facet&gt;
</code></pre>

<p><a href="http://qiita.com/okitsutakatomo/items/18cdd3db35185a9b1e99">こちら</a>は少々特殊な方法でmoduleを作成しているのでFacetの設定が不十分となってしまった模様。</p>

<h2>Facetとは</h2>

<p>FacetはIntelliJ IDEAに用意された機能で、使用するフレームワークや言語に合わせたFacetを設定することでIntelliJ IDEAが必要なコンポーネントのダウンロードや各種補完機能の設定などを行ってくれるもの。</p>

<p>Android StudioはIntelliJ IDEAをベースとして開発されたIDEなのでFacetの機能を継承している。</p>

<h2>参照</h2>

<ul>
<li><a href="http://qiita.com/okitsutakatomo/items/18cdd3db35185a9b1e99">GoogleAppEngine for Java を AndroidStudio + Gradleで開発環境を作る</a></li>
<li><a href="https://www.jetbrains.com/help/idea/2016.1/facet.html">Facet</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
